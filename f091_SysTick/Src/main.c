/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "main.h"

#define LD2_ON 		GPIOA->BSRR = GPIO_BSRR_BS_5;
#define LD2_OFF 	GPIOA->BSRR = GPIO_BSRR_BR_5;

void configureLD2(void);
void Delay(uint32_t Delay_ms);

__IO uint32_t Tick; // == volatile uint32_t Tick;

int main(void)
{
	// Konfigurujemy wewnętrzny timer w rdzeniu mcu, pracuje on po resecie na 8Mhz, pozwala wyznaczać podstawę czasu mcu
	// Posłuży nam to do generowania przerwania i implementacji blokującego delaya
	SysTick_Config(8000000 / 1000);
	configureLD2();

    /* Loop forever */
	while(1){
		LD2_ON;
		Delay(1000);
		LD2_OFF;
		Delay(1000);
	}
}

void configureLD2(void){
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
	GPIOA->MODER |= GPIO_MODER_MODER5_0;
	GPIOA->MODER &= ~(GPIO_MODER_MODER5_1);
	GPIOA->OTYPER &= ~(GPIO_OTYPER_OT_5);
	GPIOA->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR5);
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPDR5);
}

void SysTick_Handler(void){
	Tick++;
}

void Delay(uint32_t Delay_ms){
	uint32_t StartTime = Tick;
	while(Tick < (StartTime + Delay_ms)){
		// wait
	}
}
